\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}		% for algorithms in pseudo code. Usage: \begin{algorithmic}
\MakeRobust{\Call}
\newcommand{\lang}{\mathcal{L}}

\setlength{\parskip}{\smallskipamount}

\title{Analysis of Algorithms \\
\medskip
\large Homework 6 -- P vs NP}
\author{Abraham Murciano \& Elad Harizy}

\begin{document}

\maketitle

\section*{Question 1}

\subsection*{Part A}

We are to prove that if the languages \(\lang_1\) and \(\lang_2\) are in P, meaning that there automata that can tell us whether a word is in the language or not in polynomial time (\(O(n*k)\) for some constant \(k\)), then \(\lang_1 \cup \lang_2 \in P\).

Since \(\lang_1\) and \(\lang_2\) can be decided in polynomial time, their union can also, as explained in Part B.

\subsection*{Part B}

We are told that the languages \(\lang_1, \lang_2\) can be decided in polynomial time using algorithms \(A_1, A_2\) respectively, with running times \(O(n^{k_1}), O(n^{k_2})\). To decide their union, one would have to decide each one individually, and decide their union based on their logical disjunction. Thus the complexity of deciding their union is \(O(n^{k_1} + n^{k_2})\), or \(O(n^{\max(k_1, k_2)})\), which is polynomial.

\section*{Question 2}

\subsection*{Part A}

We must prove that if \(\lang \in P\) then \(\forall k \in \mathbb{N}, \lang^k \in P\). Meaning that for any constant \(k\), we can decide the concatenation of the language to itself \(k\) times, in polynomial time.

We will use a lemma which states that if \(\lang_1, \lang_2 \in P\), then \(\lang_1\lang_2 \in P\). (Proof omitted.)

We will prove this by induction.

For \(k = 0, \lang^k = \lang^0 = \{\varepsilon\} \in P\).

Assume that for \(k = n, \lang^k = \lang^n \in P\).

Then for \(k = n + 1, \lang^k = \lang^{n+1} = \lang^n \lang\). However we know that both \(\land\) and \(\lang^n\) are in \(P\), so using our lemma, their concatenation, \(\lang^{n+1}\) must be in \(P\).

\subsection*{Part B}

Given that algorithm \(A_1\) decides \(\lang\) in \(O(n^c)\) time, we are to find the complexity of an algorithm \(A_2\) which decides \(\lang^k\) for some constant \(k\).

To decide \(\lang^2\), the complexity would be \(O((n^c)^2)\), or \(O(n^{2c})\). This is because after each character, we must check if the remainder of the input is also in \(\lang\). So if we repeat this process \(k\) times, the algorithm results in a complexity of \(O(n^{kc})\).

\subsection*{Part C}

Assuming \(\lang \in P\), and is decidable in \(O(n^c)\), we are to suggest an algorithm that decides \(\lang^*\) in polynomial time. We will use a dynamic programming approach to solve this. If \(w = w_1 w_2 \dots w_n\) is a word, we shall denote by \(w_{i,j}\) (when \(i \leq j\)) the substring of \(w\) which is \(w_i w_{i+1} \dots w_j\).

We can decide that \(w \in \lang^*\) if and only if at least one of the following hold true.

\begin{itemize}
	\item \(w = \varepsilon\)
	\item \(w \in \lang\)
	\item \(\exists u v = w, \text{such that} u \in \lang^* \land v \in \lang^*\)
\end{itemize}

Using this we can compose the following algorithm.

\begin{algorithm}
	\begin{algorithmic}
		\Function{KleeneInP}{$\lang, w$}
		\If{\(w = \varepsilon\)}
		\Return True
		\EndIf
		\If{\(w \in \lang\)}
		\Return True
		\EndIf
		\For{\(i\) from 1 to \(|w|\)}
		\If{\(\Call{KleeneInP}{\lang, w_{1, i}} \land \Call{KleeneInP}{\lang, w_{i+1, |w|}}\)}
		\State \Return True
		\EndIf
		\EndFor
		\State \Return False
		\EndFunction
	\end{algorithmic}
\end{algorithm}

Assuming all results are stored in a table and are only computed once, there are \(\frac{n^2}{2}\) different substrings \(w_{i,j}\) for which the function is called. And each of those calls it checks if the substring it received is in \(\lang\), which takes \(O(n^c)\) time. Thus the time complexity of this algorithm is at most \(O(n^2 \cdot n^c) = O(n^{2c})\).

\section*{Question 3}

\subsection*{Part A}

We are to prove the transitivity of the relation \(\leq_p\), which is the relation between two languages which indicates if the first language can be reduced to the second language in polynomial time.

If \(\lang_1 \leq_p \lang_2\) then there exists some function \(f: \Sigma^* \to \Sigma^*\) which can be computed in polynomial time such that \(w \in \lang_1 \Leftrightarrow f(w) \in \lang_2\).

Similarly, if \(\lang_2 \leq_p \lang_3\) then there exists some function \(g: \Sigma^* \to \Sigma^*\) which can be computed in polynomial time such that \(f(w) \in \lang_2 \Leftrightarrow g(f(w)) \in \lang_3\).

Thus there exists a function \(h = g \circ f\) such that \(w \in \lang_1 \Leftrightarrow h(w) \in \lang_3\). And since \(f\) and \(g\) are both polynomial, \(h\), which takes the sum of the run times of \(f\) and \(g\) to run (as explained in part B), will also be polynomial. Therefore \(\lang_1 \leq_p \lang_3\), so \(\le_p\) is transitive.

\subsection*{Part B}

\end{document}