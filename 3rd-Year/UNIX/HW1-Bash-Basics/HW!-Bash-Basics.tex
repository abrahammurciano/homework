\documentclass{article}

\usepackage{listings}
\lstset{
	basicstyle=\small\ttfamily,
	columns=flexible,
	breaklines=true,
	frame=single,
	tabsize=4,
	showstringspaces=false,
}

\title{UNIX Systems \\
\medskip
\large Homework 1 -- Bash Basics}
\author{Abraham Murciano}

\begin{document}

\maketitle

\paragraph{Question 6.} If a user wants to execute a \verb`script.sh` without a shebang line or execute permissions, what should the user type?

\paragraph{Answer.} This will invoke the bash interpreter with \verb`script.sh` as a parameter. Since the bash interpreter has execute permissions, it is able to run, read the file passed to it as a parameter, and run the commands in it treating them as bash commands, since after all, it \emph{is} the bash interpreter.

\begin{lstlisting}[language=bash]
$ bash script.sh
\end{lstlisting}

\paragraph{Question 7.} Which command is being run in this script to check if \verb`file.txt` exists?

\begin{lstlisting}[language=bash]
if [ -f file.txt ]; then
	echo "file.txt exists"
fi
\end{lstlisting}

\paragraph{Answer.} It is the \verb`-f` which checks if the file exists. This also checks that it is a regular file. I.e. it is not a directory or device.

\paragraph{Question 8.} What happens if you use set -e in a Bash script?

\paragraph{Answer.} As this command shows, the \verb`-e` flag of the \verb`set` command sets the shell option to immediately exit the execution of the script if any command returns a non-zero value, indicating that it failed.

\begin{lstlisting}[language=bash]
$ set --help | grep "\-e"
-e  Exit immediately if a command exits with a non-zero status.
		errexit      same as -e
\end{lstlisting}

\paragraph{Question 9.} How does the \verb`SUID` or \verb`setuid` bit affect executable commands?

\paragraph{Answer.} When the command is executed, its running privileges elevate to the user owner of the command.

\paragraph{Question 10.} To keep a loop going until a certain condition becomes true, what would you likely use?

\paragraph{Answer.} A while loop would be appropriate for this scenario. The condition of the while loop would be the negation of the condition you want the loop to run until.

\paragraph{Question 11.} The \verb`data.txt` file is owned by \verb`root:root` with \verb`rw-------` permissions. The script will be executed by \verb`user1`. Are the two conditionals in this script the same? Explain.

\begin{lstlisting}[language=bash]
[[ -e data.txt ]] && cat data.txt || echo "data.txt doesn't exist"
if [[ -e data.txt ]]; then
	cat data.txt
else
	echo "data.txt doesn't exist"
fi
\end{lstlisting}

\paragraph{Answer.} The two conditions are different. In the first one, the test \texttt{[[ -e data.txt ]]} succeeds, since the file exists, then proceeds onto the \verb`cat` command. This command then fails since \verb`user1` does not have permission to read the file. Since the left hand side of the \verb`||` command returned false, the right hand side runs.

However, in the \verb`if` statement, the condition succeeds so it continues to the \verb`cat` command. This fails for the same reason as above, but control never reaches the else, since the condition was true.

\paragraph{Question 12.} In order to write a script that iterates through the files in a directory, which of the following could you use?

\paragraph{Answer.} The correct loop is the following one.

\begin{lstlisting}[language=bash]
for i in $(ls); do
	# ...
done
\end{lstlisting}

\paragraph{Question 13.} What is the difference between these two conditional expressions?

\begin{lstlisting}[language=bash]
[[ $A == $B ]]
[[ $A -eq $B ]]
\end{lstlisting}

\paragraph{Answer.} \verb`[[ $A == $B ]]` is used for text comparisons whereas \texttt{[[ \$A -eq \$B ]]} is used for numeric comparisons.

\paragraph{Question 14.} What is the output of this command sequence? Explain.

\begin{lstlisting}[language=bash]
cat <<EOF
--------------------------
This is line 1.
This is line 2.
This is line 3.
----------------------------
EOF
\end{lstlisting}

\paragraph{Answer.} The output of this command sequence is displayed below. The reason for it is that the \verb`cat` command is first given an end of file, then it is given a few more lines followed by another end of file. The \verb`cat` command concatenates the empty `file' with the next few lines and prints that result\dots

\paragraph{Question 15.} Given the following,

\begin{lstlisting}[language=bash]
$ ll
total 0
-rw-r--r--	1	danzig	staff	0	Jul 12	19:30	file1.text
-rw-r--r--	1	danzig	staff	0	Jul 12	19:30	file2.text
-rw-r--r--	1	danzig	staff	0	Jul 12	19:30	file3.text
-rw-r--r--	1	danzig	staff	0	Jul 12	19:30	file4.text
-rw-r--r--	1	danzig	staff	0	Jul 12	19:30	file5.text
-rw-r--r--	1	danzig	staff	0	Jul 12	19:30	file6.text
-rw-r--r--	1	danzig	staff	0	Jul 12	19:30	file7.text
\end{lstlisting}

What is the output of this line?

\begin{lstlisting}[language=bash]
$ ll | sed -e 's,file,text,g'
\end{lstlisting}

\paragraph{Answer.} This \verb`sed` command takes as input the output of \verb`ll` as shown above, and replaces all instances of the word `file' with the word `text', producing the following output.

\begin{lstlisting}[language=bash]
$ ll
total 0
-rw-r--r--	1	danzig	staff	0	Jul 12	19:30	text1.text
-rw-r--r--	1	danzig	staff	0	Jul 12	19:30	text2.text
-rw-r--r--	1	danzig	staff	0	Jul 12	19:30	text3.text
-rw-r--r--	1	danzig	staff	0	Jul 12	19:30	text4.text
-rw-r--r--	1	danzig	staff	0	Jul 12	19:30	text5.text
-rw-r--r--	1	danzig	staff	0	Jul 12	19:30	text6.text
-rw-r--r--	1	danzig	staff	0	Jul 12	19:30	text7.text
\end{lstlisting}

\paragraph{Question 16.} What is the output of this script?

\begin{lstlisting}[language=bash]

\end{lstlisting}

\end{document}